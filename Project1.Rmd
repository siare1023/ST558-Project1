---
title: "Project 1 - Vignette for Reading and Summarizing Data from the NHL API"
author: "Lucy Yin"
date: "6/20/2021"
output: 
 github_document:
  toc: true
  toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```
# Introduction
This vignette introduces my way for reading and summarizing data from the National Hockey League's (NHL) API. To access the NHL Stats API Documentation, please visit this [GitLab page](https://gitlab.com/dword4/nhlapi/-/blob/master/stats-api.md).  

# Install and load required packages
First we need to install and load in the needed packages. To install the packages, simply do `install.packages("name of package")`. After successful installation, read in the following packages. 
```{r install load packages}
library(httr)
library(jsonlite)
library(tidyverse)
library(knitr)
library(haven)
library(qwraps2)
library(rmarkdown)
library(data.table)
library(kableExtra)
library(xml2)
```

# Write functions to contact the NHL records and stats API

## NHL records API
We will need to contact the records and stats API for this vignette. First is the NHL records API. The different endpoints we will incorporate include:  
  
* franchise  
* franchise-team-totals  
* franchise-season-records  
* franchise-goalie-records  
* franchise-skater records  
* franchise-detail  
  
The function `get.records` below contacts the NHL records API and returns well-formatted, parsed data in tibble format. Users have the option to specify the franchise of choice by team's short name (such as Hurricanes, Eagles, etc.) or by the team ID number. To make this possible, we have to first map each franchise's team short name to its team ID number.    

```{r match id, name, most recent id}
# map id, team names and most recent id
franchise.url <- GET("https://records.nhl.com/site/api/franchise")
franchise.txt <- content(franchise.url, "text", encoding = "UTF-8")
franchise.json <- fromJSON(franchise.txt, flatten=TRUE)
franchise.list <- franchise.json$data %>% as.data.frame()
franchise.tbl <- tibble(franchise.list$id, franchise.list$teamCommonName, franchise.list$fullName, franchise.list$mostRecentTeamId)
franchise.tbl

# pull out the common name vector (index can serve as the id)
name.id.list <- franchise.tbl$`franchise.list$teamCommonName`
# pull out the most recent id vector (index can serve as the id)
id.most.recent.id.list <- franchise.tbl$`franchise.list$mostRecentTeamId`
```

```{r records API}
get.records <- function(table.name, id=NULL, team.common.name=NULL, ...) {
  base.url <- "https://records.nhl.com/site/api"
  
  ## table name is given
  if (!is.null(table.name)) {
    
    ## check if user input the team.common.name, if yes then convert it to the corresponding id
    if (!is.null(team.common.name)) {
      for (i in 1:length(name.id.list)) {
        if (team.common.name == name.id.list[i]) {
          id <- (i)
        }
      }
    }
    
    ## change user inputted id to most.recent.id to be used for the franchise-details table
    if (is.numeric(id)) {
      for (i in 1:length(id.most.recent.id.list)) {
        if (i == id) {
          most.recent.id <- id.most.recent.id.list[i]
        }
      }
    } 

    ## table name is this one and yes id
    if (table.name %in% ("franchise") & (is.numeric(id))) {
      return ("The table selected cannot be returned with the specified ID or team common name input.")
    }  
    
    ## yes table name, no id
    else if (is.null(id)) {
      full.url <- paste0(base.url, "/", table.name)
      
      nfl.records <- GET(full.url)
      nfl.records.txt <- content(nfl.records, "text", encoding = "UTF-8")  ## convert to JSON text form
      nfl.records.json <- fromJSON(nfl.records.txt, flatten=TRUE)  ## convert to list
      return (nfl.records.json$data %>% as_tibble())
    }
    
    ## table name is one of the 4, yes id
    else if (table.name %in% c("franchise-team-totals",
                               "franchise-season-records",
                               "franchise-goalie-records",
                               "franchise-skater-records") & 
             (is.numeric(id))) {
      full.url <- paste0(base.url, "/", table.name, "?cayenneExp=franchiseId=", id)
      nfl.records <- GET(full.url)
      nfl.records.txt <- content(nfl.records, "text", encoding = "UTF-8")  ## convert to JSON text form
      nfl.records.json <- fromJSON(nfl.records.txt, flatten=TRUE)  ## convert to list
      return (nfl.records.json$data %>% as_tibble())
    }
    
    ## table name is this, id is one of the 8 (because these results don't return html content)
    else if (table.name %in% ("franchise-detail") & 
             (id %in% c(2:4, 7:9, 13, 39))) {
      nfl.records.details <- GET(paste0(base.url, "/", table.name, "?cayenneExp=mostRecentTeamId=", most.recent.id))
      nfl.records.details.txt <- content(nfl.records.details, "text", encoding = "UTF-8")  ## convert to JSON text form
      nfl.records.details.json <- fromJSON(nfl.records.details.txt, flatten=TRUE)  ## convert to list  
      return (nfl.records.details.json$data %>% as_tibble())
    }
    
    ## table name is this, id is one of the 31 (these tibbles contain html content, further parse out html)
    else if (table.name %in% ("franchise-detail") & 
             (is.numeric(id) %in% c(1, 5 ,6, 10:12, 14:38))) {
      nfl.records.details <- GET(paste0(base.url, "/", table.name, "?cayenneExp=mostRecentTeamId=", most.recent.id))
      nfl.records.details.txt <- content(nfl.records.details, "text", encoding = "UTF-8")  ## convert to JSON text form
      nfl.records.details.json <- fromJSON(nfl.records.details.txt, flatten=TRUE)  ## convert to list
      fran.details <- nfl.records.details.json$data
      
      ## these columns contain html content, save as separate vectors
      txt.string1 <- fran.details$captainHistory
      txt.string2 <- fran.details$coachingHistory
      txt.string3 <- fran.details$generalManagerHistory
      txt.string4 <- fran.details$retiredNumbersSummary
      
      ## delete the original columns of html content
      fran.details <- fran.details %>% select(-c(3,4,8,11))

      ## use gsub function to remove all enter breaks from our character string 
      txt.string1.1 <- gsub("[\r\n\t]", "", txt.string1)
      txt.string2.1 <- gsub("[\r\n\t]", "", txt.string2)
      txt.string3.1 <- gsub("[\r\n\t]", "", txt.string3)
      txt.string4.1 <- gsub("[\r\n\t]", "", txt.string4)
      
      ## add parsed html content back into table
      fran.details$captainHistory <- read_html(txt.string1.1) %>% xml_text()
      fran.details$coachingHistory <- read_html(txt.string2.1) %>% xml_text()
      fran.details$generalManagerHistory <- read_html(txt.string3.1) %>% xml_text()
      fran.details$retiredNumbersSummary <- read_html(txt.string4.1) %>% xml_text()
      return (fran.details)
    }
  }
  
  ## table name not given
  else {
    return ("Must provide a table name to get results.")
  }
}
```

### Try out NHL records API
We can test out the `get.records` function with a few different combination of inputs to make sure the function works. 
```{r testing records}
get.records("franchise-goalie-records")
get.records("franchise-goalie-records", team.common.name = "Eagles")
get.records("franchise-detail")
get.records("franchise-detail", team.common.name = "Hurricanes")
get.records("franchise-detail", id=12)
get.records("franchise-team-totals", 26)
get.records("franchise", id=23)
get.records("franchise")

```

## NHL stats API
Next we write a function to contact the NHL stats API for the different modifiers:  
  
* team.roster  
* person.names  
* team.schedule.next  
* team.schedule.previous  
* team.stats  
* team.roster&season  
* teamId  
* statsSingleSeasonPlayoffs  

Depending on the modifier, user will need to input different variables into the function to retrieve meaningful data out. For this vignette we will only work with the `team.stats` modifier. 
```{r stat API all modifiers}
get.stat2 <- function(modifier, id=NULL, season=NULL, id2=NULL, id3=NULL, id4=NULL, ...) {
  base.url3 <- "https://statsapi.web.nhl.com/api/v1/teams"
  
  ## change the id inputs to most.recent.id to be used in this stats api section
  if (is.numeric(id)) {
    for (i in 1:length(id.most.recent.id.list)) {
      if (i == id) {
        most.recent.id <- id.most.recent.id.list[i]
      }
    }
  }
  
  if (is.numeric(id2)) {
    for (i in 1:length(id.most.recent.id.list)) {
      if (i == id2) {
        most.recent.id2 <- id.most.recent.id.list[i]
      }
    }
  }  
  
  if (is.numeric(id3)) {
    for (i in 1:length(id.most.recent.id.list)) {
      if (i == id3) {
        most.recent.id3 <- id.most.recent.id.list[i]
      }
    }
  }   

  if (is.numeric(id4)) {
    for (i in 1:length(id.most.recent.id.list)) {
      if (i == id4) {
        most.recent.id4 <- id.most.recent.id.list[i]
      }
    }
  }      
  
  ## if modifier is 1 of the 5, no id (most.recent.id)
  if (modifier %in% c("team.roster",
                      "person.names",
                      "team.schedule.next", 
                      "team.schedule.previous",  
                      "team.stats") & 
      is.null(id)) {
    full.url2 <- paste0(base.url3, "?expand=", modifier)
  }
  ## if modifier is 1 of the 5, yes id (most.recent.id)
  else if (modifier %in% c("team.roster",
                           "person.names",
                           "team.schedule.next",
                           "team.schedule.previous",
                           "team.stats") & 
           is.numeric(most.recent.id)) {
    full.url2 <- paste0(base.url3, "/", most.recent.id, "?expand=", modifier)
  }
  
  ## if modifier is this, no id (most.recent.id), yes season
  else if (modifier %in% ("team.roster&season") & 
           is.null(id) & 
           is.numeric(season)) {
    full.url2 <- paste0(base.url3, "?expand=", modifier, "=", season)
  }
  
  ## if modifier is this, yes id (most.recent.id), yes season
  else if (modifier %in% ("team.roster&season") & 
           is.numeric(most.recent.id) & 
           is.numeric(season)) {
    full.url2 <- paste0(base.url3, "/", most.recent.id, "?expand=", modifier, "=", season)
  }  
  
  ## if modifier is this, no season
  else if (modifier %in% ("team.roster&season") & is.null(season)) {
    return ("Must provide a season input to get the team roster & season stats.")
  }    

  ## if modifier is this, multiple id's (most recent id's) given
  else if (modifier %in% ("teamId") & 
           is.numeric(c(most.recent.id, most.recent.id2, most.recent.id3, most.recent.id4))) {
    full.url2 <- paste0(base.url3, "?", modifier, "=",
                        paste(most.recent.id, most.recent.id2, most.recent.id3, most.recent.id4, sep = ","))
  }
  ## if modifier is this, no id (most recent id)
  else if (modifier %in% ("statsSingleSeasonPlayoffs") & is.null(id)) {
    full.url2 <- paste0(base.url3, "?stats=", modifier)
  }
  
  ## if modifier is this, yes id (most.recent.id)
  else if (modifier %in% ("statsSingleSeasonPlayoffs") & is.numeric(most.recent.id)) {
    full.url2 <- paste0(base.url3, "/", most.recent.id, "?stats=", modifier)
  }
  
  ## all other combinations
  else {
    return ("Invalid input, please try again.")  
  }
      
  nfl.stats3 <- GET(full.url2)
  nfl.stats3.txt <- content(nfl.stats3, "text", encoding = "UTF-8")
  nfl.stats3.json<- fromJSON(nfl.stats3.txt, flatten=TRUE)
  
  ## because returned tibble has data frames within, need to unnest twice to parse out everything  
  return (nfl.stats3.json$teams %>% unnest(everything()) %>% unnest(everything()) %>% as_tibble())

}
```

### Try out NHL stats API
We use the `get.stats2` function above and retrieved the `team.stats` table. We see for each team there are 2 rows, first row has all the raw data, the second row has the ranking information. So we can separate this into two different tables by accessing the odd or even rows. 
```{r testing stat}
get.stat2("team.stats", 26)

get.stats.data <- get.stat2("team.stats")
row.odd <- seq_len(nrow(get.stats.data)) %% 2  ## Create row indicator
row.odd ## Print row indicator

# subset odd rows where numbers are given in raw
data.row.odd <- get.stats.data[row.odd == 1, ]
data.row.odd

# subset even rows where ranks are given instead of raw number
data.row.even.ranks <- get.stats.data[row.odd == 0, ]
data.row.even.ranks
```

## Wrapper Function
We write a wrapper function as the one-stop-shop for the user to access any of the API endpoints above. This wrapper function can let user access both the `get.records` and `get.stats2` functions using any modifiers, teamID's, team names, etc. 
```{r wrapper all mod}
get.nhl.data <- function (table.name=NULL, 
                          modifier=NULL, 
                          id=NULL, 
                          team.common.name=NULL, 
                          season=NULL, 
                          id2=NULL, id3=NULL, id4=NULL, ...) {

  ## yes table name, yes modifier
  if (!is.null(table.name) & !is.null(modifier)) {
    stop ("Cannot use both table name and modifier to get back information.")
  }
  
  ## yes table name
  else if (!is.null(table.name) & is.null(team.common.name) & is.null(id) & is.null(modifier)) {
    output <- get.records(table.name)
  }  
  
  ## yes table name, yes id or team.common.name, no modifier
  else if (!is.null(table.name) & (is.numeric(id) | !is.null(team.common.name)) & is.null(modifier)) {
    output <- get.records(table.name, id, team.common.name)
  }
  
  ## yes modifier
  else if (!is.null(modifier) & is.null(table.name) & is.null(id) & is.null(team.common.name)) {
    output <- get.stat2(modifier)
  }
  
  ## yes modifier, yes id
  else if (!is.null(modifier) & is.null(table.name) & is.numeric(id)) {
    output <- get.stat2(modifier, id)
  }
  
  ## yes modifier, yes season
  else if (!is.null(modifier) & is.null(table.name) & !is.null(season)) {
    output <- get.stat2(modifier, season)
  }
  
  ## yes modifier, yes multiple id
  else if (!is.null(modifier) & is.null(table.name) & is.numeric(id) & is.numeric(id2)) {
    output <- get.stat2(modifier, id, id2, id3, id4)
  }
  
  ## all other combinations
  else {
    return ("Invalid combination of inputs, please try again.")
  }
  
  return(output)
}
```

### Try out wrapper function
We can try a few different combinations to make sure the `get.nhl.data` wrapper function works properly. 
```{r try wrapper all mod}
get.nhl.data(table.name = "franchise-detail", id=12)
get.nhl.data(table.name = "franchise-team-totals")
get.nhl.data(modifier = "person.names", id = 26, season = 20142015)
get.nhl.data(modifier = "team.stats", id = 26)
```

# Exporatory Data Analysis
After setting up the functions to retrieve data from the NHL API, we can grab data to specifically do exploratory data analysis. 

## Grabbing data and combine
First we can use the wrapper function to retrieve the `franchise-team-totals` data, filter by specific fields to only retain information for the 31 current active teams. Then we can retrieve the `team.stats` data and only keep the odd rows (which are the raw data without ranking). 
```{r grabbing data from 2 tables}
# get all information from "franchise-team-totals"
team.total.raw <- get.nhl.data(table.name = "franchise-team-totals") 

# filter to get only the 31 active teams
team.total <- team.total.raw %>% rename(abbreviation = triCode) %>% 
  select(activeFranchise, gameTypeId, lastSeasonId, everything()) %>%
  filter(activeFranchise==1 & gameTypeId==2 & is.na(lastSeasonId))
team.total

# get division data for different teams from "team.stats"
division.raw <- get.nhl.data(modifier = "team.stats")

# select only odd rows (does not include ranks), then select useful columns
row.odd2 <- seq_len(nrow(division.raw)) %% 2  ## Create row indicator

division <- division.raw[row.odd2 == 1, ] %>%
  select(franchiseId, venue.name, venue.city, 
         division.id, division.name, conference.id, conference.name)
division
```
We find out what columns are present in both of these tables then left join using a common index (in this case we use the franchiseId) to create a new combined data named `new.data`. 
```{r combining tables}
# find common columns between the 2 data frames
common.names.dv <- intersect(names(team.total), names(division))
common.names.dv

# combine the 2 tables (join matching rows from division to team.total) together using "franchiseId" as index
new.data <- left_join(team.total, division, by="franchiseId")
new.data
```

## Create new variables
After the new table `new.data` is created, we can add in new variables that are functions of the existing variables. We append these new variables into the `new.data` table as new columns. 
```{r new variable}

# % of wins from all games played
new.data$perc.total.games.win <- (new.data$wins / new.data$gamesPlayed * 100) %>% round(2)

# % of losses from all games played
new.data$perc.total.games.loss <- (new.data$losses / new.data$gamesPlayed * 100) %>% round(2)

# % of wins from home games
new.data$perc.home.win <- (new.data$homeWins / (new.data$homeLosses + new.data$homeOvertimeLosses + new.data$homeTies + new.data$homeWins) *100) %>% round(2)

# % of losses from home games
new.data$perc.home.loss <- (new.data$homeLosses / (new.data$homeLosses + new.data$homeOvertimeLosses + new.data$homeTies + new.data$homeWins) *100) %>% round(2)

# % of wins from road games
new.data$perc.road.win <- (new.data$roadWins / (new.data$roadLosses + new.data$roadOvertimeLosses + new.data$roadTies + new.data$roadWins) *100) %>% round(2)

# % of losses from road games
new.data$perc.road.loss <- (new.data$roadLosses / (new.data$roadLosses + new.data$roadOvertimeLosses + new.data$roadTies + new.data$roadWins) *100) %>% round(2)

new.data %>% 
  select(perc.total.games.win, perc.total.games.loss, perc.home.win, perc.home.loss, perc.road.win, perc.road.loss, 
         everything())

```

## Read data from 2 different endpoints and combine
Another good example of reading data from 2 different endpoints and combining them together is finding common columns within the `franchise-goalie-records` and `franchise-skater-records` tables, select only the common columns for each table then row bind them together. This way we end up with a complete list of player information for all player positions.  
  
Below is how we combine player information for the Hurricanes franchise (teamID=26). 
```{r read data from 2 api and combine - hurricanes}
# read from goalie records endpoint for hurricanes
goalie.records <- get.nhl.data(table.name = "franchise-goalie-records", id = 26)
goalie.records

# read from skater records endpoint for hurricanes
skater.records <- get.nhl.data(table.name = "franchise-skater-records", id = 26)
skater.records

# find common columns between the two tibbles
common.names <- intersect(names(goalie.records), names(skater.records))
common.names

# only keep common columns in each tibble
goalie.records <- goalie.records %>% select(all_of(common.names))
skater.records <- skater.records %>% select(all_of(common.names))

# combine the 2 tibbles together by binding rows
hurricanes.players.record <- rbind(goalie.records, skater.records)
hurricanes.players.record
```
And we can do similar things to compile a complete list of players information for all positions for all franchises. We can also add in the franchise division information to the players information by left joining using `franchiseId` as the index. 
```{r read data from 2 api and combine - all teams}
# read from goalie records endpoint for all teams
goalie.records2 <- get.nhl.data(table.name = "franchise-goalie-records")
goalie.records2

# read from skater records endpoint for all teams
skater.records2 <- get.nhl.data(table.name = "franchise-skater-records")
skater.records2

# find common columns between the two tibbles
common.names <- intersect(names(goalie.records2), names(skater.records2))
common.names

# only keep common columns in each tibble
goalie.records2 <- goalie.records2 %>% select(all_of(common.names))
skater.records2 <- skater.records2 %>% select(all_of(common.names))

# combine the 2 tibbles together
players.record.all <- rbind(goalie.records2, skater.records2)
players.record.all

# find common columns between the above tibble and the previous division tibble
common.names.players <- intersect(names(players.record.all), names(division))
common.names.players

# combine 2 tibbles together (matching rows from division to players.record.all) using franchiseId as index
new.data.players <- left_join(players.record.all, division, by="franchiseId")
new.data.players
```

## Contingency Tables
After grabbing data and combining them into new tables, we can now create contingency tables. Contingency tables summarize the relationship between several categorical variables. Here we looks at 2 categorical variables at a time to examine their relationship. First we look at each categorical variable separately, then we can use the `table` and `kable` functions to create nice contingency tables.  
  
Here we first look at how many active and inactive players are in each franchise. Then we also look at what proportion of total active/inactive players are in each franchise. 
```{r contingency table active/inactive}
# see how many players are in each team
table(players.record.all$franchiseName)

# see how many active and inactive players are in each time
table(players.record.all$activePlayer)

# find the count of active/inactive players by franchise
contingency.table.players <- table(players.record.all$franchiseName, players.record.all$activePlayer) %>% 
  kable(caption = "Contingency Table of Active (TRUE) / Inactive (FALSE) Player Count by Franchise")
contingency.table.players

# find the proportion by margin=2 (by column)
contingency.table.players.prop <- table(players.record.all$franchiseName, players.record.all$activePlayer) %>%
  prop.table(margin=2)*100
contingency.table.players.prop %>% 
  kable(caption = "Proportion of all Active (TRUE) / Inactive (FALSE) Players by Franchise") 
```

We also create a second contingency table to look at how many franchises within a specific division had over 1500 total game wins. We also look at each categorical variable separately first, then combine the two variables into a contingency table. We also look at what proportion of teams within each division had over 1500 wins. 
```{r contingency table wins and division}
# see how many teams are in each division
table(new.data$division.name)

# see how many games are won among all teams
table(new.data$wins)

# find the count of franchises w/i a division that had over 1500 wins
contingency.table2 <- table(new.data$division.name, new.data$wins>1500) %>%
  kable(caption = "Contingency Table of Number of Franchises in a Division that had Over 1500 Wins")
contingency.table2

# find the proportion by margin=1 (by rows)
contingency.table2.prop <- table(new.data$division.name, new.data$wins>1500) %>%
  prop.table(margin=1)*100
contingency.table2.prop %>%
  kable(caption = "Proportion of Teams with Over 1500 Win within Each Division")

```

## Numerical Summaries for Categorical Variables
With lots of data to play with, we can create numerical summaries for the categorical variables. We can specifically look at each setting of a particular categorical variable and see summaries of the quantitative variables. We look at a few numerical summaries below. 
```{r numerical summaries}
# find the average games played by each position
new.data.players %>% group_by(positionCode) %>% 
  summarize(avg.games.played = mean(gamesPlayed))

# find the average games played by each position and division name
new.data.players %>% drop_na() %>% group_by(positionCode, division.name) %>% 
  summarize(avg.games.played = mean(gamesPlayed))

# find the 5 number summary (and mean) of the percentage of total games won by all teams
new.data %>% select(perc.total.games.win) %>% summary()

# find the 5 number summary (and mean) of the percentage of total games lost by all teams
new.data %>% select(perc.total.games.loss) %>% summary()

# find the average percent of games won for home vs. road games by division
new.data %>% select(-3) %>% drop_na() %>% 
  group_by(division.name) %>% 
  summarize(avg.perc.home.win = mean(perc.home.win), avg.perc.road.win = mean(perc.road.win))

# find the average percent of games lost for home vs. road games by division
new.data %>% select(-3) %>% drop_na() %>% 
  group_by(division.name) %>% 
  summarize(avg.perc.home.loss = mean(perc.home.loss), avg.perc.road.loss = mean(perc.road.loss))

```

## Plots
A fun part of exploratory data analysis is creating visuals for more eye-catching representation of the data. We will create bar plots, histograms, box plot, and scatter plots using different data to demonstrate this. 

### Bar plot
We create 2 bar plots. The first bar plot looks at how many franchises are in each division with indication of conference in a stacked position. As someone who's not familiar with hockey, this is a good starting point to get to know the basics of NHL. We see from this bar plot that 3 of the 4 divisions have 8 franchises, the fourth division only has 7 franchises. What makes this plot interesting, contrary to my initial thought, is that there are not 2 divisions per conference. Although we see that all of the 8 franchises in the Honda West division belong to the Western Conference, and all of the 8 franchises in the MassMutual East division belong to the Eastern Conference, for the other two divisions we have almost half of the franchises belonging to the Eastern Conference while the other half belonging to the Western Conference. This makes me want to investigate further how a team is classified into a division or a conference. 
```{r plot - bar - new.data}
ggplot(data = new.data, aes(x = division.name)) + 
  geom_bar(aes(fill = as.factor(conference.name)), position = "stack") + 
  labs(x = "Division", title = "Bar Plot of Number of Franchise in Each Division with Indication of Conference") + 
  scale_fill_discrete(name = "Conference Name", labels = c("Eastern Conference", "Western Conference"))
```

For the second bar plot, we look at the number of players by position with indication of their active or inactive statuses. The bars are shown in a dodge position. We see out of all the players in the table, the position with the most players is defense, position with the least players is goalie (which makes sense, since we do don't typically need many goalies per team). The table has records of a lot more inactive players compared to active players, this is clearly shown by the height of pink and blue bars. We have similar numbers of active center and defence players, but a lot more defence players are inactive compared to the center players. After looking at this plot, I'd want to look up how many players are needed to play in a hockey game, and how many are for each position. 
```{r plot - bar - players.record.all}
ggplot(data = players.record.all, aes(x = positionCode)) + 
  geom_bar(aes(fill = as.factor(activePlayer)), position = "dodge") + 
  labs(x = "Position", title = "Number of Players by Position with Indication of Active or Inactive Status") + 
  scale_x_discrete(labels = c("Center", "Defense", "Goalie", "Left Wing", "Right Wing")) +
  scale_fill_discrete(name = "Active/Inactive Players", labels = c("Inactive", "Active"))
```

### Histogram
We also create 2 histograms. For the first histogram we look at how many games each player has played. Based on this histogram, we see majority of the players have played up to around 100 games, while the most games played is above 1500, which is shockingly impressive. We can confirm this by doing a `summary` function on the gamesPlayed column of the `players.record.all` table, the result indicates the maximum numbers of games played is 1687, while the mean number of games played is around 115. With this result, I'd want to look up how many seasons of games a typical NHL player plays in his career, and how many games are typically in a season. 

```{r plot - histogram - players.record.all}
ggplot(data = players.record.all, aes(x = gamesPlayed)) +
  geom_histogram(color = "purple", fill = "orange") +
  labs(x = "Games Played", title = "Number of Games Played by each (of all) Players")

summary(players.record.all$gamesPlayed)
```

The second histogram breaks up the histogram by position of the players, this is done by adding a facet layer of positions on top of the histogram layer. We see the shape of the distribution of games played for each position follows similar patterns, although the height of bars are different, this is most likely contributed by the different numbers of players for each position previously shown by the bar plot. We cannot quite pinpoint which positioned player played 1687 games based on this histogram. 
```{r plot - histogram facet - player.record.all}
ggplot(data = players.record.all, aes(x = gamesPlayed)) +
  geom_histogram(color = "purple", fill = "orange") +
  facet_grid(~ positionCode, 
             labeller = as_labeller(c(C = "Center", D = "Defense", G = "Goalie", L = "Left Wing", R = "Right Wing"))) +
  labs(x = "Games Played", title = "Number of Games Played by each (of all) Players by Position Played")
```

### Box Plot
For this box plot, we look at how many games are played for each division, the mean games played for division indicated by each conference is shown by the two lines. Box plots show the 5 number summary with dots indicating possible outliers. Based on this box plot, we see that the numbers of games played for the Honda West division is generally lower than the other 3 divisions. The games played in the Scotia North division seems to be the most varied compared to the other 3 division, with the widest spread. We see the medium games played for the Discover Central and Honda West divisions are about the same, but other measures are quite different including minimum, 25th percentile, 75th percentile and the maximum number of games. We see there are a couple of possible outlier values for both the Discover Central and MassMutual East divisions. Looking at the mean values indicated also by conference name, we see the Western Conference blue line doesn't cross the MassMutual East division's box plot at all, this makes sense since we saw from previous plots that all of the 8 teams in this division belong to the Eastern Conference. Similarly, the red line crosses the box plot of Honda West at a strange location, this is due to the fact that all of the 8 teams in the Honda West division belong in the Western Conference. Therefore, means are not calculated for these two divisions for these two conferences. For the Discover Central division, Western Conference teams have a higher mean games played compared to the Eastern Conference teams, this is interesting because we saw from previous plots that there are actually more Eastern Conference teams in this division. And for the Scotia North division, the mean number of games played for the Eastern Conference teams are a lot higher than those from the Western Conference teams, this is also interesting because there are only slightly more teams in the Western Conference than those in the Eastern Conference. So based off this plot, we can conclude that the number of games played vary greatly depending on which division a particular team's in, the mean number of games played can also vary greatly based on the conference.   
```{r plot - box plot - new.data}
ggplot(data = new.data, aes(x = division.name, y = gamesPlayed)) +
  geom_boxplot(fill = "maroon") +
  stat_summary(fun = mean, geom = "line", aes(group = conference.name, col = conference.name)) +
  labs(x = "Division Name", y = "# of Games Played", title = "Number of Games Played for Each Division with Mean Games Played for Each Conference")
```


### Scatter Plot

We now look at a few scatter plots. For the first scatter plot, we look at the number of games won versus the number of games lost for each of the 31 active franchises. Each dot represents a franchise, the blue line represents the generalized additive model smoother, while the yellow line represents the best fit linear model smoother. I also added a black diagonal abline representing the 1 to 1 ratio of wins and losses. Looking specifically at the black line, we see all but 4 teams are below the line, indicating that these teams have higher numbers of wins than losses. The best fit linear model line has a slightly smaller slope but does not fit all of the data well. The blue generalized additive model smoother fits the data better. 
```{r plot - scatter - new.data}
ggplot(data = new.data, aes(x = wins, y = losses)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1) +  ## diagonal line indicating 1-1 ratio for win/losses
  geom_smooth() +   ## generalized additive model smoother in blue
  geom_smooth(method = lm, col = "yellow") +  ## best fit linear model smoother
  labs(x = "Games Won", y = "Games Lost", title = "Number of Games Won vs. Number of Games Lost for Each Franchise")
```
  
Next we look at the same data but break up the 31 teams into each conference, this is done by adding a facet layer to the scatter plot layer. Looking specifically at the black diagonal line, we see that all except 1 team in the Eastern Conference are below the line (teams below the line have higher number of wins compared to losses), and we have 3 teams above the line for the Western Conference. The yellow best fit linear model smoother line has a bigger slope for the Western Conference compared to the Eastern, indicating that teams in the Western Conference generally have close to same number of wins and losses, while the teams in the Eastern Conference tend to have more games won than lost. The generalized additive model smoother for the Western Conference is very close to the yellow best fit linear model smoother, while the generalized additive model smoother for the Eastern Conference varies a bit from the best fit linear model smoother towards the larger games won values. 
```{r plot - scatter facet}
ggplot(data = new.data, aes(x = wins, y = losses)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1) +  ## diagonal line indicating 1-1 ratio for win/losses
  geom_smooth() +   ## generalized additive model smoother in blue
  geom_smooth(method = lm, col = "yellow") +  ## best fit linear model smoother
  facet_grid(~ conference.name, labeller = as_labeller(c(Eastern = "Eastern Conference", 
                                      Western = "Western Conference"))) +
  labs(x = "Games Won", y = "Games Lost", title = "Number of Games Won vs. Number of Games Lost for Franchies in Each Division")
```

### Scatter Plot using Group
Next, we further subset the number of total games won and loss. For these next 4 plots, we will use the `group=conference.name` to get a clearer idea of which teams belong to which conference.  
  
This first plot, we look at the number of home games won versus the number of home games lost for each team with indication of conference. We see for these home games, almost all teams have higher numbers of games won compared to games lost. The purple line represent the best fit linear model smoother for the Western Conference teams (blue dots), and the green line represent the besst fit linear model smoother for the Eastern Conference teams (orange dots). We see the smoother for the Western Conference has a bigger slope than the Eastern Conference, this seem to indicate when comparing with the Eastern Conference teams, the Western Conference teams have less difference in the number of wins minus losses for home games. The Eastern Conference teams tend to have even higher number of home games won compared to home games lost. 
```{r plot - point and group - home games}
ggplot(data = new.data, aes(x = homeWins, y = homeLosses)) +
  geom_point(aes(fill=conference.name, color=conference.name, group=conference.name)) +
  geom_abline(intercept=0, slope=1) +  ## diagonal line indicating 1-1 ratio for win/losses
  geom_smooth(data = subset(new.data, conference.name=="Eastern"),
              method = "lm", color = "springgreen") +  ## best fit linear model smoother
  geom_smooth(data = subset(new.data, conference.name=="Western"),
              method = "lm", color = "slateblue") +  ## best fit linear model smoother
  labs(x = "Home Games Won", y = "Home Games Lost", title = "Number of Home Games Won vs. Lost for Each Franchise by Conference")
```

Next we look at how many road games are won versus how many road games are lost. Here we see we have all but 2 teams on the black line, indicating that most of the Eastern Conference teams have higher number road games lost compared to road games won. We have about 5 teams in the Western Conference that are on or below the line, the other teams in this conference also have higher number of road games lost compared to road games won. Here the best fit linear model smoother for the Western Conference has larger slope than the smoother for the Eastern Conference, this seem to suggest that while more Western Conference teams are below the black line (meaning these teams have higher number of road game wins than losses), some of the Western Conference teams that are above the black line will have bigger difference of number of road games lost minus won. We can also draw a conclusion that teams tend to do better for home games compared to road games, regardless of which conference the team's in.  
```{r plot - point and group - road games}
ggplot(data = new.data, aes(x = roadWins, y = roadLosses)) +
  geom_point(aes(fill=conference.name, color=conference.name, group=conference.name)) +
  geom_abline(intercept=0, slope=1) +  ## diagonal line indicating 1-1 ratio for win/losses
  geom_smooth(data = subset(new.data, conference.name=="Eastern"),
              method = "lm", color = "springgreen") +  ## best fit linear model smoother
  geom_smooth(data = subset(new.data, conference.name=="Western"),
              method = "lm", color = "slateblue") +  ## best fit linear model smoother
  labs(x = "Road Games Won", y = "Road Games Lost", title = "Number of Road Games Won vs. Lost for Each Franchise by Conference")
```
  
It also is worth while to look at the percentage of home games won versus percentage of road games won for each team as indicated by conference. The diagonal black line is barely visible at the upper left corner, meaning all of the teams are well below this black line. So all of the teams have a higher percentage of home games won compared to road games won. The best fit linear model smoother for the Eastern Conference has a smaller slope, so these teams tend to have a larger difference in the percentage of home games won minus percentage of road games won. But all of these teams do way better on home games, which further confirms our previous conclusion.  
```{r plot - point and group - perc won games}
ggplot(data = new.data, aes(x = perc.home.win, y = perc.road.win)) +
  geom_point(aes(fill=conference.name, color=conference.name, group=conference.name)) +
  geom_abline(intercept=0, slope=1) +  ## diagonal line indicating 1-1 ratio for win/losses
  geom_smooth(data = subset(new.data, conference.name=="Eastern"),
              method = "lm", color = "springgreen") +  ## best fit linear model smoother
  geom_smooth(data = subset(new.data, conference.name=="Western"),
              method = "lm", color = "slateblue") +  ## best fit linear model smoother
  labs(x = "% of Home Games Won", y = "% Road Games Won", title = "% of Home Games Won vs. Road Games Won for Each Franchise by Conference")
```
  
Similarly, we can look at the percentage of home games lost compared to percentage of road games lost. The diagonal black line is barely visible at the lower right of the plot, so all of these teams are above the line meaning they all have higher percentage of road games lost compared to percentage of home games lost. The best fit linear model smoother is flatter for the Eastern Conference teams, meaning these teams tend to have larger difference of percentage of home games lost minus percentage of road games lost. All of these teams do worse on road games. 
```{r plot - point and group - perc lost games}
ggplot(data = new.data, aes(x = perc.home.loss, y = perc.road.loss)) +
  geom_point(aes(fill=conference.name, color=conference.name, group=conference.name)) +
  geom_abline(intercept=0, slope=1) +  ## diagonal line indicating 1-1 ratio for win/losses
  geom_smooth(data = subset(new.data, conference.name=="Eastern"),
              method = "lm", color = "springgreen") +  ## best fit linear model smoother
  geom_smooth(data = subset(new.data, conference.name=="Western"),
              method = "lm", color = "slateblue") +  ## best fit linear model smoother
  labs(x = "% of Home Games Loss", y = "% Road Games Loss", title = "% of Home Games Win vs. Road Games Loss for Each Franchise by Conference")
```


# Outro
I hope you found this vignette useful. If you have any suggestions, questions, comments, please send them to me at [xyin2@ncsu.edu](mailto:xyin2@ncsu.edu). Thank you. 